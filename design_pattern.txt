##############################设计模式8大原则##############################
1) 依赖倒置原则：DIP
    *高层模块(稳定)不应该依赖于低层模块(不稳定)，二者应该同时依赖于抽象(稳定)。
    *抽象(稳定)不应该依赖于实现细节(不稳定)，实现细节应该依赖于抽象(稳定)。

2) 开放封闭原则：OCP
    *对扩展开放，对修改封闭。
    *类模块应该是可扩展的，但是不可修改的。

3) 单一职责原则：SRP
    *一个类应该仅有一个引起它变化的原因。
    *变化的方向隐含着类的责任。

4) LisKov替换原则：LSP
    *子类必须能够替换它们的基类(IS-A)。
    *继承表达类型抽象。

5) 接口隔离原则：ISP
    *不应该强迫客户程序依赖它们不使用的方法。
    *接口应该小而完备。

6) 优先使用对象组合，而不是继承
    *类继承通常为"白箱复用"，对象组合通常为"黑箱复用"。
    *继承某种程序上破坏了封装性，子类父类耦合度高。
    *而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

7) 封装变化点
    *使用封装来创建对象之间的分界层，让设计者可以在分界层一侧进行修改，
    而不会对另一侧产生不良的影响,从而实现层次间的松耦合。

8) 针对接口编程，而不是针对实现编程
   *不将变量类型声明为某个特定的具体类，而是声明为某个接口。
   *客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。
   *减少系统中各部分之间的依赖关系，从而实现"高内聚、低耦合"的类型设计方案。

##############################23种设计模式##############################
（1）创建型
1、工厂方法(Factory Method)
    
2、抽象工厂(Abstract Factory)

3、原型(Prototype)

4、单例模式(Singleton)

5、生成器(Builder)  //非常用


（2）结构型
1、装饰器(Decorator)

4、适配器(Adapter)

2、组合(Composite)

3、桥接(Bridge)

5、外观(Facade)

6、享元(Flyweight)

7、代理(Proxy)


（3）行为设计模式
1、模板(Template Method)

2、观察者(Observer)

3、状态(State)

4、策略(Strategy)

5、中介者(Mediator) //非常用

6、备忘录(Memento)  //非常用

7、迭代器(Iterator) //非常用

8、命令(Command)    //非常用

9、责任链(Chain of Responsibility)  //非常用 

10、访问者(Visitor)  //非常用

11、解释器(Interpreter)  //非常用

